/* tslint:disable */
/* eslint-disable */
/**
 * Travel API
 * API for Travel app
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * * `easy` - Легкий * `medium` - Средний * `hard` - Сложный
 * @export
 * @enum {string}
 */

export const DifficultyEnum = {
    Easy: 'easy',
    Medium: 'medium',
    Hard: 'hard'
} as const;

export type DifficultyEnum = typeof DifficultyEnum[keyof typeof DifficultyEnum];


/**
 * 
 * @export
 * @interface District
 */
export interface District {
    /**
     * 
     * @type {number}
     * @memberof District
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof District
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof District
     */
    'administrative_center'?: number | null;
}
/**
 * 
 * @export
 * @interface Logout
 */
export interface Logout {
    /**
     * 
     * @type {string}
     * @memberof Logout
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface News
 */
export interface News {
    /**
     * 
     * @type {number}
     * @memberof News
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface PaginatedDistrictList
 */
export interface PaginatedDistrictList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDistrictList
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedDistrictList
     */
    'page_size': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDistrictList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDistrictList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<District>}
     * @memberof PaginatedDistrictList
     */
    'results': Array<District>;
}
/**
 * 
 * @export
 * @interface PaginatedNewsList
 */
export interface PaginatedNewsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedNewsList
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedNewsList
     */
    'page_size': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNewsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNewsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<News>}
     * @memberof PaginatedNewsList
     */
    'results': Array<News>;
}
/**
 * 
 * @export
 * @interface PaginatedPlaceListList
 */
export interface PaginatedPlaceListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPlaceListList
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedPlaceListList
     */
    'page_size': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPlaceListList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPlaceListList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<PlaceList>}
     * @memberof PaginatedPlaceListList
     */
    'results': Array<PlaceList>;
}
/**
 * 
 * @export
 * @interface PaginatedRouterListList
 */
export interface PaginatedRouterListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRouterListList
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedRouterListList
     */
    'page_size': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRouterListList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRouterListList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<RouterList>}
     * @memberof PaginatedRouterListList
     */
    'results': Array<RouterList>;
}
/**
 * 
 * @export
 * @interface PaginatedSettlementList
 */
export interface PaginatedSettlementList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSettlementList
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedSettlementList
     */
    'page_size': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSettlementList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSettlementList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Settlement>}
     * @memberof PaginatedSettlementList
     */
    'results': Array<Settlement>;
}
/**
 * 
 * @export
 * @interface PatchedUser
 */
export interface PatchedUser {
    /**
     * 
     * @type {number}
     * @memberof PatchedUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'last_name'?: string;
}
/**
 * 
 * @export
 * @interface PlaceDetail
 */
export interface PlaceDetail {
    /**
     * 
     * @type {number}
     * @memberof PlaceDetail
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PlaceDetail
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PlaceDetail
     */
    'short_description': string;
    /**
     * 
     * @type {string}
     * @memberof PlaceDetail
     */
    'full_description': string;
    /**
     * 
     * @type {number}
     * @memberof PlaceDetail
     */
    'district'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceDetail
     */
    'district_name': string;
    /**
     * 
     * @type {number}
     * @memberof PlaceDetail
     */
    'settlement'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceDetail
     */
    'settlement_name': string;
    /**
     * 
     * @type {string}
     * @memberof PlaceDetail
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof PlaceDetail
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<PlaceImage>}
     * @memberof PlaceDetail
     */
    'images': Array<PlaceImage>;
}
/**
 * 
 * @export
 * @interface PlaceImage
 */
export interface PlaceImage {
    /**
     * 
     * @type {number}
     * @memberof PlaceImage
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PlaceImage
     */
    'image': string;
    /**
     * 
     * @type {number}
     * @memberof PlaceImage
     */
    'order'?: number;
}
/**
 * 
 * @export
 * @interface PlaceList
 */
export interface PlaceList {
    /**
     * 
     * @type {number}
     * @memberof PlaceList
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PlaceList
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PlaceList
     */
    'short_description': string;
    /**
     * 
     * @type {number}
     * @memberof PlaceList
     */
    'district'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceList
     */
    'district_name': string;
    /**
     * 
     * @type {number}
     * @memberof PlaceList
     */
    'settlement'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlaceList
     */
    'settlement_name': string;
    /**
     * 
     * @type {string}
     * @memberof PlaceList
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof PlaceList
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<PlaceImage>}
     * @memberof PlaceList
     */
    'images': Array<PlaceImage>;
}
/**
 * 
 * @export
 * @interface RouterDetail
 */
export interface RouterDetail {
    /**
     * 
     * @type {number}
     * @memberof RouterDetail
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof RouterDetail
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof RouterDetail
     */
    'short_description': string;
    /**
     * 
     * @type {string}
     * @memberof RouterDetail
     */
    'full_description': string;
    /**
     * Загрузите изображение для маршрута
     * @type {string}
     * @memberof RouterDetail
     */
    'image'?: string | null;
    /**
     * Укажите продолжительность маршрута в формате ЧЧ:ММ:СС
     * @type {string}
     * @memberof RouterDetail
     */
    'duration': string;
    /**
     * Выберите уровень сложности маршрута  * `easy` - Легкий * `medium` - Средний * `hard` - Сложный
     * @type {DifficultyEnum}
     * @memberof RouterDetail
     */
    'difficulty'?: DifficultyEnum;
    /**
     * 
     * @type {string}
     * @memberof RouterDetail
     */
    'district_name': string;
    /**
     * 
     * @type {string}
     * @memberof RouterDetail
     */
    'settlement_name': string;
    /**
     * 
     * @type {string}
     * @memberof RouterDetail
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof RouterDetail
     */
    'updated_at': string;
}


/**
 * 
 * @export
 * @interface RouterList
 */
export interface RouterList {
    /**
     * 
     * @type {number}
     * @memberof RouterList
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof RouterList
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof RouterList
     */
    'short_description': string;
    /**
     * Загрузите изображение для маршрута
     * @type {string}
     * @memberof RouterList
     */
    'image'?: string | null;
    /**
     * Укажите продолжительность маршрута в формате ЧЧ:ММ:СС
     * @type {string}
     * @memberof RouterList
     */
    'duration': string;
    /**
     * Выберите уровень сложности маршрута  * `easy` - Легкий * `medium` - Средний * `hard` - Сложный
     * @type {DifficultyEnum}
     * @memberof RouterList
     */
    'difficulty'?: DifficultyEnum;
    /**
     * 
     * @type {string}
     * @memberof RouterList
     */
    'district_name': string;
    /**
     * 
     * @type {string}
     * @memberof RouterList
     */
    'settlement_name': string;
    /**
     * 
     * @type {string}
     * @memberof RouterList
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof RouterList
     */
    'updated_at': string;
}


/**
 * 
 * @export
 * @interface Settlement
 */
export interface Settlement {
    /**
     * 
     * @type {number}
     * @memberof Settlement
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Settlement
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Settlement
     */
    'district'?: number | null;
    /**
     * 
     * @type {TypeEnum}
     * @memberof Settlement
     */
    'type'?: TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Settlement
     */
    'type_display': string;
    /**
     * 
     * @type {string}
     * @memberof Settlement
     */
    'is_city_district': string;
}


/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenVerify
 */
export interface TokenVerify {
    /**
     * 
     * @type {string}
     * @memberof TokenVerify
     */
    'token': string;
}
/**
 * * `city` - Город * `town` - Посёлок городского типа * `village` - Село * `village_hamlet` - Деревня
 * @export
 * @enum {string}
 */

export const TypeEnum = {
    City: 'city',
    Town: 'town',
    Village: 'village',
    VillageHamlet: 'village_hamlet'
} as const;

export type TypeEnum = typeof TypeEnum[keyof typeof TypeEnum];


/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {number}
     * @memberof UserCreate
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'password': string;
}

/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Logout a user by blacklisting their refresh token
         * @param {Logout} logout 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsLogoutCreate: async (logout: Logout, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logout' is not null or undefined
            assertParamExists('apiAccountsLogoutCreate', 'logout', logout)
            const localVarPath = `/api/accounts/logout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logout, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsProfilePartialUpdate: async (patchedUser?: PatchedUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounts/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsProfileRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounts/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsProfileUpdate: async (user?: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounts/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user account
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsRegisterCreate: async (userCreate: UserCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('apiAccountsRegisterCreate', 'userCreate', userCreate)
            const localVarPath = `/api/accounts/register/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsTokenCreate: async (tokenObtainPair: TokenObtainPair, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenObtainPair' is not null or undefined
            assertParamExists('apiAccountsTokenCreate', 'tokenObtainPair', tokenObtainPair)
            const localVarPath = `/api/accounts/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsTokenRefreshCreate: async (tokenRefresh: TokenRefresh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefresh' is not null or undefined
            assertParamExists('apiAccountsTokenRefreshCreate', 'tokenRefresh', tokenRefresh)
            const localVarPath = `/api/accounts/token/refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefresh, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsTokenVerifyCreate: async (tokenVerify: TokenVerify, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenVerify' is not null or undefined
            assertParamExists('apiAccountsTokenVerifyCreate', 'tokenVerify', tokenVerify)
            const localVarPath = `/api/accounts/token/verify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenVerify, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint для чтения данных о районах
         * @param {string} [name] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLocationsDistrictsList: async (name?: string, ordering?: string, page?: number, pageSize?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/locations/districts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint для чтения данных о районах
         * @param {number} id A unique integer value identifying this Район.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLocationsDistrictsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiLocationsDistrictsRetrieve', 'id', id)
            const localVarPath = `/api/locations/districts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint для чтения данных о населенных пунктах
         * @param {number} [district] 
         * @param {string} [name] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {ApiLocationsSettlementsListTypeEnum} [type] * &#x60;city&#x60; - Город * &#x60;town&#x60; - Посёлок городского типа * &#x60;village&#x60; - Село * &#x60;village_hamlet&#x60; - Деревня
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLocationsSettlementsList: async (district?: number, name?: string, ordering?: string, page?: number, pageSize?: number, search?: string, type?: ApiLocationsSettlementsListTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/locations/settlements/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (district !== undefined) {
                localVarQueryParameter['district'] = district;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint для чтения данных о населенных пунктах
         * @param {number} id A unique integer value identifying this Населённый пункт.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLocationsSettlementsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiLocationsSettlementsRetrieve', 'id', id)
            const localVarPath = `/api/locations/settlements/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNewsList: async (ordering?: string, page?: number, pageSize?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/news/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Новость.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNewsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiNewsRetrieve', 'id', id)
            const localVarPath = `/api/news/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [district] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {number} [settlement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlacesList: async (district?: number, ordering?: string, page?: number, pageSize?: number, search?: string, settlement?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/places/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (district !== undefined) {
                localVarQueryParameter['district'] = district;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (settlement !== undefined) {
                localVarQueryParameter['settlement'] = settlement;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Интересное место.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlacesRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPlacesRetrieve', 'id', id)
            const localVarPath = `/api/places/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [district] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {number} [settlement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRoutersList: async (district?: number, ordering?: string, page?: number, pageSize?: number, search?: string, settlement?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/routers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (district !== undefined) {
                localVarQueryParameter['district'] = district;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (settlement !== undefined) {
                localVarQueryParameter['settlement'] = settlement;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Маршрут.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRoutersRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRoutersRetrieve', 'id', id)
            const localVarPath = `/api/routers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiApiAxiosParamCreator(configuration)
    return {
        /**
         * Logout a user by blacklisting their refresh token
         * @param {Logout} logout 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsLogoutCreate(logout: Logout, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsLogoutCreate(logout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsLogoutCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsProfilePartialUpdate(patchedUser?: PatchedUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsProfilePartialUpdate(patchedUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsProfilePartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsProfileRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsProfileRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsProfileRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsProfileUpdate(user?: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsProfileUpdate(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsProfileUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user account
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsRegisterCreate(userCreate: UserCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsRegisterCreate(userCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsRegisterCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsTokenCreate(tokenObtainPair: TokenObtainPair, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenObtainPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsTokenCreate(tokenObtainPair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsTokenCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsTokenRefreshCreate(tokenRefresh: TokenRefresh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefresh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsTokenRefreshCreate(tokenRefresh, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsTokenRefreshCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsTokenVerifyCreate(tokenVerify: TokenVerify, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenVerify>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsTokenVerifyCreate(tokenVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsTokenVerifyCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint для чтения данных о районах
         * @param {string} [name] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiLocationsDistrictsList(name?: string, ordering?: string, page?: number, pageSize?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDistrictList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiLocationsDistrictsList(name, ordering, page, pageSize, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiLocationsDistrictsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint для чтения данных о районах
         * @param {number} id A unique integer value identifying this Район.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiLocationsDistrictsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<District>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiLocationsDistrictsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiLocationsDistrictsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint для чтения данных о населенных пунктах
         * @param {number} [district] 
         * @param {string} [name] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {ApiLocationsSettlementsListTypeEnum} [type] * &#x60;city&#x60; - Город * &#x60;town&#x60; - Посёлок городского типа * &#x60;village&#x60; - Село * &#x60;village_hamlet&#x60; - Деревня
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiLocationsSettlementsList(district?: number, name?: string, ordering?: string, page?: number, pageSize?: number, search?: string, type?: ApiLocationsSettlementsListTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSettlementList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiLocationsSettlementsList(district, name, ordering, page, pageSize, search, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiLocationsSettlementsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint для чтения данных о населенных пунктах
         * @param {number} id A unique integer value identifying this Населённый пункт.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiLocationsSettlementsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Settlement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiLocationsSettlementsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiLocationsSettlementsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNewsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedNewsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNewsList(ordering, page, pageSize, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiNewsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Новость.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNewsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<News>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNewsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiNewsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [district] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {number} [settlement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPlacesList(district?: number, ordering?: string, page?: number, pageSize?: number, search?: string, settlement?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPlaceListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPlacesList(district, ordering, page, pageSize, search, settlement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiPlacesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Интересное место.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPlacesRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPlacesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiPlacesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [district] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {number} [settlement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRoutersList(district?: number, ordering?: string, page?: number, pageSize?: number, search?: string, settlement?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRouterListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRoutersList(district, ordering, page, pageSize, search, settlement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiRoutersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Маршрут.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRoutersRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouterDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRoutersRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiRoutersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiApiFp(configuration)
    return {
        /**
         * Logout a user by blacklisting their refresh token
         * @param {ApiApiApiAccountsLogoutCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsLogoutCreate(requestParameters: ApiApiApiAccountsLogoutCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiAccountsLogoutCreate(requestParameters.logout, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiApiApiAccountsProfilePartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsProfilePartialUpdate(requestParameters: ApiApiApiAccountsProfilePartialUpdateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.apiAccountsProfilePartialUpdate(requestParameters.patchedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsProfileRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.apiAccountsProfileRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiApiApiAccountsProfileUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsProfileUpdate(requestParameters: ApiApiApiAccountsProfileUpdateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.apiAccountsProfileUpdate(requestParameters.user, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user account
         * @param {ApiApiApiAccountsRegisterCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsRegisterCreate(requestParameters: ApiApiApiAccountsRegisterCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserCreate> {
            return localVarFp.apiAccountsRegisterCreate(requestParameters.userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {ApiApiApiAccountsTokenCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsTokenCreate(requestParameters: ApiApiApiAccountsTokenCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenObtainPair> {
            return localVarFp.apiAccountsTokenCreate(requestParameters.tokenObtainPair, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {ApiApiApiAccountsTokenRefreshCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsTokenRefreshCreate(requestParameters: ApiApiApiAccountsTokenRefreshCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenRefresh> {
            return localVarFp.apiAccountsTokenRefreshCreate(requestParameters.tokenRefresh, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {ApiApiApiAccountsTokenVerifyCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsTokenVerifyCreate(requestParameters: ApiApiApiAccountsTokenVerifyCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenVerify> {
            return localVarFp.apiAccountsTokenVerifyCreate(requestParameters.tokenVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint для чтения данных о районах
         * @param {ApiApiApiLocationsDistrictsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLocationsDistrictsList(requestParameters: ApiApiApiLocationsDistrictsListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDistrictList> {
            return localVarFp.apiLocationsDistrictsList(requestParameters.name, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint для чтения данных о районах
         * @param {ApiApiApiLocationsDistrictsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLocationsDistrictsRetrieve(requestParameters: ApiApiApiLocationsDistrictsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<District> {
            return localVarFp.apiLocationsDistrictsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint для чтения данных о населенных пунктах
         * @param {ApiApiApiLocationsSettlementsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLocationsSettlementsList(requestParameters: ApiApiApiLocationsSettlementsListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedSettlementList> {
            return localVarFp.apiLocationsSettlementsList(requestParameters.district, requestParameters.name, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint для чтения данных о населенных пунктах
         * @param {ApiApiApiLocationsSettlementsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLocationsSettlementsRetrieve(requestParameters: ApiApiApiLocationsSettlementsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<Settlement> {
            return localVarFp.apiLocationsSettlementsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiApiApiNewsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNewsList(requestParameters: ApiApiApiNewsListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedNewsList> {
            return localVarFp.apiNewsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiApiApiNewsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNewsRetrieve(requestParameters: ApiApiApiNewsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<News> {
            return localVarFp.apiNewsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiApiApiPlacesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlacesList(requestParameters: ApiApiApiPlacesListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPlaceListList> {
            return localVarFp.apiPlacesList(requestParameters.district, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, requestParameters.settlement, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiApiApiPlacesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlacesRetrieve(requestParameters: ApiApiApiPlacesRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<PlaceDetail> {
            return localVarFp.apiPlacesRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiApiApiRoutersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRoutersList(requestParameters: ApiApiApiRoutersListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRouterListList> {
            return localVarFp.apiRoutersList(requestParameters.district, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, requestParameters.settlement, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiApiApiRoutersRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRoutersRetrieve(requestParameters: ApiApiApiRoutersRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<RouterDetail> {
            return localVarFp.apiRoutersRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiApi - interface
 * @export
 * @interface ApiApi
 */
export interface ApiApiInterface {
    /**
     * Logout a user by blacklisting their refresh token
     * @param {ApiApiApiAccountsLogoutCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsLogoutCreate(requestParameters: ApiApiApiAccountsLogoutCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {ApiApiApiAccountsProfilePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsProfilePartialUpdate(requestParameters?: ApiApiApiAccountsProfilePartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsProfileRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @param {ApiApiApiAccountsProfileUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsProfileUpdate(requestParameters?: ApiApiApiAccountsProfileUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<User>;

    /**
     * Create a new user account
     * @param {ApiApiApiAccountsRegisterCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsRegisterCreate(requestParameters: ApiApiApiAccountsRegisterCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserCreate>;

    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {ApiApiApiAccountsTokenCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsTokenCreate(requestParameters: ApiApiApiAccountsTokenCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenObtainPair>;

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {ApiApiApiAccountsTokenRefreshCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsTokenRefreshCreate(requestParameters: ApiApiApiAccountsTokenRefreshCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenRefresh>;

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     * @param {ApiApiApiAccountsTokenVerifyCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsTokenVerifyCreate(requestParameters: ApiApiApiAccountsTokenVerifyCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenVerify>;

    /**
     * API endpoint для чтения данных о районах
     * @param {ApiApiApiLocationsDistrictsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiLocationsDistrictsList(requestParameters?: ApiApiApiLocationsDistrictsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDistrictList>;

    /**
     * API endpoint для чтения данных о районах
     * @param {ApiApiApiLocationsDistrictsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiLocationsDistrictsRetrieve(requestParameters: ApiApiApiLocationsDistrictsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<District>;

    /**
     * API endpoint для чтения данных о населенных пунктах
     * @param {ApiApiApiLocationsSettlementsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiLocationsSettlementsList(requestParameters?: ApiApiApiLocationsSettlementsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedSettlementList>;

    /**
     * API endpoint для чтения данных о населенных пунктах
     * @param {ApiApiApiLocationsSettlementsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiLocationsSettlementsRetrieve(requestParameters: ApiApiApiLocationsSettlementsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<Settlement>;

    /**
     * 
     * @param {ApiApiApiNewsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiNewsList(requestParameters?: ApiApiApiNewsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedNewsList>;

    /**
     * 
     * @param {ApiApiApiNewsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiNewsRetrieve(requestParameters: ApiApiApiNewsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<News>;

    /**
     * 
     * @param {ApiApiApiPlacesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiPlacesList(requestParameters?: ApiApiApiPlacesListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPlaceListList>;

    /**
     * 
     * @param {ApiApiApiPlacesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiPlacesRetrieve(requestParameters: ApiApiApiPlacesRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<PlaceDetail>;

    /**
     * 
     * @param {ApiApiApiRoutersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiRoutersList(requestParameters?: ApiApiApiRoutersListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRouterListList>;

    /**
     * 
     * @param {ApiApiApiRoutersRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiRoutersRetrieve(requestParameters: ApiApiApiRoutersRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<RouterDetail>;

}

/**
 * Request parameters for apiAccountsLogoutCreate operation in ApiApi.
 * @export
 * @interface ApiApiApiAccountsLogoutCreateRequest
 */
export interface ApiApiApiAccountsLogoutCreateRequest {
    /**
     * 
     * @type {Logout}
     * @memberof ApiApiApiAccountsLogoutCreate
     */
    readonly logout: Logout
}

/**
 * Request parameters for apiAccountsProfilePartialUpdate operation in ApiApi.
 * @export
 * @interface ApiApiApiAccountsProfilePartialUpdateRequest
 */
export interface ApiApiApiAccountsProfilePartialUpdateRequest {
    /**
     * 
     * @type {PatchedUser}
     * @memberof ApiApiApiAccountsProfilePartialUpdate
     */
    readonly patchedUser?: PatchedUser
}

/**
 * Request parameters for apiAccountsProfileUpdate operation in ApiApi.
 * @export
 * @interface ApiApiApiAccountsProfileUpdateRequest
 */
export interface ApiApiApiAccountsProfileUpdateRequest {
    /**
     * 
     * @type {User}
     * @memberof ApiApiApiAccountsProfileUpdate
     */
    readonly user?: User
}

/**
 * Request parameters for apiAccountsRegisterCreate operation in ApiApi.
 * @export
 * @interface ApiApiApiAccountsRegisterCreateRequest
 */
export interface ApiApiApiAccountsRegisterCreateRequest {
    /**
     * 
     * @type {UserCreate}
     * @memberof ApiApiApiAccountsRegisterCreate
     */
    readonly userCreate: UserCreate
}

/**
 * Request parameters for apiAccountsTokenCreate operation in ApiApi.
 * @export
 * @interface ApiApiApiAccountsTokenCreateRequest
 */
export interface ApiApiApiAccountsTokenCreateRequest {
    /**
     * 
     * @type {TokenObtainPair}
     * @memberof ApiApiApiAccountsTokenCreate
     */
    readonly tokenObtainPair: TokenObtainPair
}

/**
 * Request parameters for apiAccountsTokenRefreshCreate operation in ApiApi.
 * @export
 * @interface ApiApiApiAccountsTokenRefreshCreateRequest
 */
export interface ApiApiApiAccountsTokenRefreshCreateRequest {
    /**
     * 
     * @type {TokenRefresh}
     * @memberof ApiApiApiAccountsTokenRefreshCreate
     */
    readonly tokenRefresh: TokenRefresh
}

/**
 * Request parameters for apiAccountsTokenVerifyCreate operation in ApiApi.
 * @export
 * @interface ApiApiApiAccountsTokenVerifyCreateRequest
 */
export interface ApiApiApiAccountsTokenVerifyCreateRequest {
    /**
     * 
     * @type {TokenVerify}
     * @memberof ApiApiApiAccountsTokenVerifyCreate
     */
    readonly tokenVerify: TokenVerify
}

/**
 * Request parameters for apiLocationsDistrictsList operation in ApiApi.
 * @export
 * @interface ApiApiApiLocationsDistrictsListRequest
 */
export interface ApiApiApiLocationsDistrictsListRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiApiApiLocationsDistrictsList
     */
    readonly name?: string

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof ApiApiApiLocationsDistrictsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof ApiApiApiLocationsDistrictsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ApiApiApiLocationsDistrictsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof ApiApiApiLocationsDistrictsList
     */
    readonly search?: string
}

/**
 * Request parameters for apiLocationsDistrictsRetrieve operation in ApiApi.
 * @export
 * @interface ApiApiApiLocationsDistrictsRetrieveRequest
 */
export interface ApiApiApiLocationsDistrictsRetrieveRequest {
    /**
     * A unique integer value identifying this Район.
     * @type {number}
     * @memberof ApiApiApiLocationsDistrictsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for apiLocationsSettlementsList operation in ApiApi.
 * @export
 * @interface ApiApiApiLocationsSettlementsListRequest
 */
export interface ApiApiApiLocationsSettlementsListRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiApiApiLocationsSettlementsList
     */
    readonly district?: number

    /**
     * 
     * @type {string}
     * @memberof ApiApiApiLocationsSettlementsList
     */
    readonly name?: string

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof ApiApiApiLocationsSettlementsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof ApiApiApiLocationsSettlementsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ApiApiApiLocationsSettlementsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof ApiApiApiLocationsSettlementsList
     */
    readonly search?: string

    /**
     * * &#x60;city&#x60; - Город * &#x60;town&#x60; - Посёлок городского типа * &#x60;village&#x60; - Село * &#x60;village_hamlet&#x60; - Деревня
     * @type {'city' | 'town' | 'village' | 'village_hamlet'}
     * @memberof ApiApiApiLocationsSettlementsList
     */
    readonly type?: ApiLocationsSettlementsListTypeEnum
}

/**
 * Request parameters for apiLocationsSettlementsRetrieve operation in ApiApi.
 * @export
 * @interface ApiApiApiLocationsSettlementsRetrieveRequest
 */
export interface ApiApiApiLocationsSettlementsRetrieveRequest {
    /**
     * A unique integer value identifying this Населённый пункт.
     * @type {number}
     * @memberof ApiApiApiLocationsSettlementsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for apiNewsList operation in ApiApi.
 * @export
 * @interface ApiApiApiNewsListRequest
 */
export interface ApiApiApiNewsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof ApiApiApiNewsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof ApiApiApiNewsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ApiApiApiNewsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof ApiApiApiNewsList
     */
    readonly search?: string
}

/**
 * Request parameters for apiNewsRetrieve operation in ApiApi.
 * @export
 * @interface ApiApiApiNewsRetrieveRequest
 */
export interface ApiApiApiNewsRetrieveRequest {
    /**
     * A unique integer value identifying this Новость.
     * @type {number}
     * @memberof ApiApiApiNewsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for apiPlacesList operation in ApiApi.
 * @export
 * @interface ApiApiApiPlacesListRequest
 */
export interface ApiApiApiPlacesListRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiApiApiPlacesList
     */
    readonly district?: number

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof ApiApiApiPlacesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof ApiApiApiPlacesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ApiApiApiPlacesList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof ApiApiApiPlacesList
     */
    readonly search?: string

    /**
     * 
     * @type {number}
     * @memberof ApiApiApiPlacesList
     */
    readonly settlement?: number
}

/**
 * Request parameters for apiPlacesRetrieve operation in ApiApi.
 * @export
 * @interface ApiApiApiPlacesRetrieveRequest
 */
export interface ApiApiApiPlacesRetrieveRequest {
    /**
     * A unique integer value identifying this Интересное место.
     * @type {number}
     * @memberof ApiApiApiPlacesRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for apiRoutersList operation in ApiApi.
 * @export
 * @interface ApiApiApiRoutersListRequest
 */
export interface ApiApiApiRoutersListRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiApiApiRoutersList
     */
    readonly district?: number

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof ApiApiApiRoutersList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof ApiApiApiRoutersList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ApiApiApiRoutersList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof ApiApiApiRoutersList
     */
    readonly search?: string

    /**
     * 
     * @type {number}
     * @memberof ApiApiApiRoutersList
     */
    readonly settlement?: number
}

/**
 * Request parameters for apiRoutersRetrieve operation in ApiApi.
 * @export
 * @interface ApiApiApiRoutersRetrieveRequest
 */
export interface ApiApiApiRoutersRetrieveRequest {
    /**
     * A unique integer value identifying this Маршрут.
     * @type {number}
     * @memberof ApiApiApiRoutersRetrieve
     */
    readonly id: number
}

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI implements ApiApiInterface {
    /**
     * Logout a user by blacklisting their refresh token
     * @param {ApiApiApiAccountsLogoutCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsLogoutCreate(requestParameters: ApiApiApiAccountsLogoutCreateRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsLogoutCreate(requestParameters.logout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiApiApiAccountsProfilePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsProfilePartialUpdate(requestParameters: ApiApiApiAccountsProfilePartialUpdateRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsProfilePartialUpdate(requestParameters.patchedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsProfileRetrieve(options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsProfileRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiApiApiAccountsProfileUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsProfileUpdate(requestParameters: ApiApiApiAccountsProfileUpdateRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsProfileUpdate(requestParameters.user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user account
     * @param {ApiApiApiAccountsRegisterCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsRegisterCreate(requestParameters: ApiApiApiAccountsRegisterCreateRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsRegisterCreate(requestParameters.userCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {ApiApiApiAccountsTokenCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsTokenCreate(requestParameters: ApiApiApiAccountsTokenCreateRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsTokenCreate(requestParameters.tokenObtainPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {ApiApiApiAccountsTokenRefreshCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsTokenRefreshCreate(requestParameters: ApiApiApiAccountsTokenRefreshCreateRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsTokenRefreshCreate(requestParameters.tokenRefresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     * @param {ApiApiApiAccountsTokenVerifyCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsTokenVerifyCreate(requestParameters: ApiApiApiAccountsTokenVerifyCreateRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsTokenVerifyCreate(requestParameters.tokenVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint для чтения данных о районах
     * @param {ApiApiApiLocationsDistrictsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiLocationsDistrictsList(requestParameters: ApiApiApiLocationsDistrictsListRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiLocationsDistrictsList(requestParameters.name, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint для чтения данных о районах
     * @param {ApiApiApiLocationsDistrictsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiLocationsDistrictsRetrieve(requestParameters: ApiApiApiLocationsDistrictsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiLocationsDistrictsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint для чтения данных о населенных пунктах
     * @param {ApiApiApiLocationsSettlementsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiLocationsSettlementsList(requestParameters: ApiApiApiLocationsSettlementsListRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiLocationsSettlementsList(requestParameters.district, requestParameters.name, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint для чтения данных о населенных пунктах
     * @param {ApiApiApiLocationsSettlementsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiLocationsSettlementsRetrieve(requestParameters: ApiApiApiLocationsSettlementsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiLocationsSettlementsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiApiApiNewsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiNewsList(requestParameters: ApiApiApiNewsListRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiNewsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiApiApiNewsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiNewsRetrieve(requestParameters: ApiApiApiNewsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiNewsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiApiApiPlacesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiPlacesList(requestParameters: ApiApiApiPlacesListRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiPlacesList(requestParameters.district, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, requestParameters.settlement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiApiApiPlacesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiPlacesRetrieve(requestParameters: ApiApiApiPlacesRetrieveRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiPlacesRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiApiApiRoutersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRoutersList(requestParameters: ApiApiApiRoutersListRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiRoutersList(requestParameters.district, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, requestParameters.settlement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiApiApiRoutersRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRoutersRetrieve(requestParameters: ApiApiApiRoutersRetrieveRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiRoutersRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ApiLocationsSettlementsListTypeEnum = {
    City: 'city',
    Town: 'town',
    Village: 'village',
    VillageHamlet: 'village_hamlet'
} as const;
export type ApiLocationsSettlementsListTypeEnum = typeof ApiLocationsSettlementsListTypeEnum[keyof typeof ApiLocationsSettlementsListTypeEnum];


