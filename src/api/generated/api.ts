/* tslint:disable */
/* eslint-disable */
/**
 * Travel API
 * API for Travel app
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Logout
 */
export interface Logout {
    /**
     * 
     * @type {string}
     * @memberof Logout
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface News
 */
export interface News {
    /**
     * 
     * @type {number}
     * @memberof News
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface PaginatedNewsList
 */
export interface PaginatedNewsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedNewsList
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedNewsList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<News>}
     * @memberof PaginatedNewsList
     */
    'results': Array<News>;
}
/**
 * 
 * @export
 * @interface PatchedUser
 */
export interface PatchedUser {
    /**
     * 
     * @type {number}
     * @memberof PatchedUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'last_name'?: string;
}
/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenVerify
 */
export interface TokenVerify {
    /**
     * 
     * @type {string}
     * @memberof TokenVerify
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {number}
     * @memberof UserCreate
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'password': string;
}

/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Logout a user by blacklisting their refresh token
         * @param {Logout} logout 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsLogoutCreate: async (logout: Logout, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logout' is not null or undefined
            assertParamExists('apiAccountsLogoutCreate', 'logout', logout)
            const localVarPath = `/api/accounts/logout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logout, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsProfilePartialUpdate: async (patchedUser?: PatchedUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounts/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsProfileRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounts/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsProfileUpdate: async (user?: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounts/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user account
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsRegisterCreate: async (userCreate: UserCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('apiAccountsRegisterCreate', 'userCreate', userCreate)
            const localVarPath = `/api/accounts/register/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsTokenCreate: async (tokenObtainPair: TokenObtainPair, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenObtainPair' is not null or undefined
            assertParamExists('apiAccountsTokenCreate', 'tokenObtainPair', tokenObtainPair)
            const localVarPath = `/api/accounts/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsTokenRefreshCreate: async (tokenRefresh: TokenRefresh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefresh' is not null or undefined
            assertParamExists('apiAccountsTokenRefreshCreate', 'tokenRefresh', tokenRefresh)
            const localVarPath = `/api/accounts/token/refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefresh, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsTokenVerifyCreate: async (tokenVerify: TokenVerify, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenVerify' is not null or undefined
            assertParamExists('apiAccountsTokenVerifyCreate', 'tokenVerify', tokenVerify)
            const localVarPath = `/api/accounts/token/verify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenVerify, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNewsList: async (ordering?: string, page?: number, pageSize?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/news/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNewsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiNewsRetrieve', 'id', id)
            const localVarPath = `/api/news/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiApiAxiosParamCreator(configuration)
    return {
        /**
         * Logout a user by blacklisting their refresh token
         * @param {Logout} logout 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsLogoutCreate(logout: Logout, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsLogoutCreate(logout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsLogoutCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsProfilePartialUpdate(patchedUser?: PatchedUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsProfilePartialUpdate(patchedUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsProfilePartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsProfileRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsProfileRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsProfileRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsProfileUpdate(user?: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsProfileUpdate(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsProfileUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user account
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsRegisterCreate(userCreate: UserCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsRegisterCreate(userCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsRegisterCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsTokenCreate(tokenObtainPair: TokenObtainPair, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenObtainPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsTokenCreate(tokenObtainPair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsTokenCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsTokenRefreshCreate(tokenRefresh: TokenRefresh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefresh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsTokenRefreshCreate(tokenRefresh, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsTokenRefreshCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountsTokenVerifyCreate(tokenVerify: TokenVerify, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenVerify>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountsTokenVerifyCreate(tokenVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiAccountsTokenVerifyCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNewsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedNewsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNewsList(ordering, page, pageSize, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiNewsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNewsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<News>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNewsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.apiNewsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiApiFp(configuration)
    return {
        /**
         * Logout a user by blacklisting their refresh token
         * @param {ApiApiApiAccountsLogoutCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsLogoutCreate(requestParameters: ApiApiApiAccountsLogoutCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiAccountsLogoutCreate(requestParameters.logout, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiApiApiAccountsProfilePartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsProfilePartialUpdate(requestParameters: ApiApiApiAccountsProfilePartialUpdateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.apiAccountsProfilePartialUpdate(requestParameters.patchedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsProfileRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.apiAccountsProfileRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiApiApiAccountsProfileUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsProfileUpdate(requestParameters: ApiApiApiAccountsProfileUpdateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.apiAccountsProfileUpdate(requestParameters.user, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user account
         * @param {ApiApiApiAccountsRegisterCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsRegisterCreate(requestParameters: ApiApiApiAccountsRegisterCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserCreate> {
            return localVarFp.apiAccountsRegisterCreate(requestParameters.userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {ApiApiApiAccountsTokenCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsTokenCreate(requestParameters: ApiApiApiAccountsTokenCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenObtainPair> {
            return localVarFp.apiAccountsTokenCreate(requestParameters.tokenObtainPair, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {ApiApiApiAccountsTokenRefreshCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsTokenRefreshCreate(requestParameters: ApiApiApiAccountsTokenRefreshCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenRefresh> {
            return localVarFp.apiAccountsTokenRefreshCreate(requestParameters.tokenRefresh, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {ApiApiApiAccountsTokenVerifyCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountsTokenVerifyCreate(requestParameters: ApiApiApiAccountsTokenVerifyCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenVerify> {
            return localVarFp.apiAccountsTokenVerifyCreate(requestParameters.tokenVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiApiApiNewsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNewsList(requestParameters: ApiApiApiNewsListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedNewsList> {
            return localVarFp.apiNewsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiApiApiNewsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNewsRetrieve(requestParameters: ApiApiApiNewsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<News> {
            return localVarFp.apiNewsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiApi - interface
 * @export
 * @interface ApiApi
 */
export interface ApiApiInterface {
    /**
     * Logout a user by blacklisting their refresh token
     * @param {ApiApiApiAccountsLogoutCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsLogoutCreate(requestParameters: ApiApiApiAccountsLogoutCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {ApiApiApiAccountsProfilePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsProfilePartialUpdate(requestParameters?: ApiApiApiAccountsProfilePartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsProfileRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @param {ApiApiApiAccountsProfileUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsProfileUpdate(requestParameters?: ApiApiApiAccountsProfileUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<User>;

    /**
     * Create a new user account
     * @param {ApiApiApiAccountsRegisterCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsRegisterCreate(requestParameters: ApiApiApiAccountsRegisterCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserCreate>;

    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {ApiApiApiAccountsTokenCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsTokenCreate(requestParameters: ApiApiApiAccountsTokenCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenObtainPair>;

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {ApiApiApiAccountsTokenRefreshCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsTokenRefreshCreate(requestParameters: ApiApiApiAccountsTokenRefreshCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenRefresh>;

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     * @param {ApiApiApiAccountsTokenVerifyCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAccountsTokenVerifyCreate(requestParameters: ApiApiApiAccountsTokenVerifyCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenVerify>;

    /**
     * 
     * @param {ApiApiApiNewsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiNewsList(requestParameters?: ApiApiApiNewsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedNewsList>;

    /**
     * 
     * @param {ApiApiApiNewsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiNewsRetrieve(requestParameters: ApiApiApiNewsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<News>;

}

/**
 * Request parameters for apiAccountsLogoutCreate operation in ApiApi.
 * @export
 * @interface ApiApiApiAccountsLogoutCreateRequest
 */
export interface ApiApiApiAccountsLogoutCreateRequest {
    /**
     * 
     * @type {Logout}
     * @memberof ApiApiApiAccountsLogoutCreate
     */
    readonly logout: Logout
}

/**
 * Request parameters for apiAccountsProfilePartialUpdate operation in ApiApi.
 * @export
 * @interface ApiApiApiAccountsProfilePartialUpdateRequest
 */
export interface ApiApiApiAccountsProfilePartialUpdateRequest {
    /**
     * 
     * @type {PatchedUser}
     * @memberof ApiApiApiAccountsProfilePartialUpdate
     */
    readonly patchedUser?: PatchedUser
}

/**
 * Request parameters for apiAccountsProfileUpdate operation in ApiApi.
 * @export
 * @interface ApiApiApiAccountsProfileUpdateRequest
 */
export interface ApiApiApiAccountsProfileUpdateRequest {
    /**
     * 
     * @type {User}
     * @memberof ApiApiApiAccountsProfileUpdate
     */
    readonly user?: User
}

/**
 * Request parameters for apiAccountsRegisterCreate operation in ApiApi.
 * @export
 * @interface ApiApiApiAccountsRegisterCreateRequest
 */
export interface ApiApiApiAccountsRegisterCreateRequest {
    /**
     * 
     * @type {UserCreate}
     * @memberof ApiApiApiAccountsRegisterCreate
     */
    readonly userCreate: UserCreate
}

/**
 * Request parameters for apiAccountsTokenCreate operation in ApiApi.
 * @export
 * @interface ApiApiApiAccountsTokenCreateRequest
 */
export interface ApiApiApiAccountsTokenCreateRequest {
    /**
     * 
     * @type {TokenObtainPair}
     * @memberof ApiApiApiAccountsTokenCreate
     */
    readonly tokenObtainPair: TokenObtainPair
}

/**
 * Request parameters for apiAccountsTokenRefreshCreate operation in ApiApi.
 * @export
 * @interface ApiApiApiAccountsTokenRefreshCreateRequest
 */
export interface ApiApiApiAccountsTokenRefreshCreateRequest {
    /**
     * 
     * @type {TokenRefresh}
     * @memberof ApiApiApiAccountsTokenRefreshCreate
     */
    readonly tokenRefresh: TokenRefresh
}

/**
 * Request parameters for apiAccountsTokenVerifyCreate operation in ApiApi.
 * @export
 * @interface ApiApiApiAccountsTokenVerifyCreateRequest
 */
export interface ApiApiApiAccountsTokenVerifyCreateRequest {
    /**
     * 
     * @type {TokenVerify}
     * @memberof ApiApiApiAccountsTokenVerifyCreate
     */
    readonly tokenVerify: TokenVerify
}

/**
 * Request parameters for apiNewsList operation in ApiApi.
 * @export
 * @interface ApiApiApiNewsListRequest
 */
export interface ApiApiApiNewsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof ApiApiApiNewsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof ApiApiApiNewsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ApiApiApiNewsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof ApiApiApiNewsList
     */
    readonly search?: string
}

/**
 * Request parameters for apiNewsRetrieve operation in ApiApi.
 * @export
 * @interface ApiApiApiNewsRetrieveRequest
 */
export interface ApiApiApiNewsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiApiApiNewsRetrieve
     */
    readonly id: number
}

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI implements ApiApiInterface {
    /**
     * Logout a user by blacklisting their refresh token
     * @param {ApiApiApiAccountsLogoutCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsLogoutCreate(requestParameters: ApiApiApiAccountsLogoutCreateRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsLogoutCreate(requestParameters.logout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiApiApiAccountsProfilePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsProfilePartialUpdate(requestParameters: ApiApiApiAccountsProfilePartialUpdateRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsProfilePartialUpdate(requestParameters.patchedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsProfileRetrieve(options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsProfileRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiApiApiAccountsProfileUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsProfileUpdate(requestParameters: ApiApiApiAccountsProfileUpdateRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsProfileUpdate(requestParameters.user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user account
     * @param {ApiApiApiAccountsRegisterCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsRegisterCreate(requestParameters: ApiApiApiAccountsRegisterCreateRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsRegisterCreate(requestParameters.userCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {ApiApiApiAccountsTokenCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsTokenCreate(requestParameters: ApiApiApiAccountsTokenCreateRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsTokenCreate(requestParameters.tokenObtainPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {ApiApiApiAccountsTokenRefreshCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsTokenRefreshCreate(requestParameters: ApiApiApiAccountsTokenRefreshCreateRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsTokenRefreshCreate(requestParameters.tokenRefresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     * @param {ApiApiApiAccountsTokenVerifyCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccountsTokenVerifyCreate(requestParameters: ApiApiApiAccountsTokenVerifyCreateRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiAccountsTokenVerifyCreate(requestParameters.tokenVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiApiApiNewsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiNewsList(requestParameters: ApiApiApiNewsListRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiNewsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiApiApiNewsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiNewsRetrieve(requestParameters: ApiApiApiNewsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiNewsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



